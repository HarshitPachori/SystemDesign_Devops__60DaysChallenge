---
title: "Day 09: Docker "
description: "A summary of my 9th day's learning in the 60-day challenge, covering basic cloud concepts , storage and an overview of docker and multi stage builds."
keywords:
  - AWS
  - EC2
  - Docker
  - Multi Stage Builds
  - Day 9
  - Challenge
---

### Table of contents :
- [What is Docker ?](#what-is-docker-)
- [What is Docker Compose ?](#what-is-docker-compose-)
- [What is Docker Volumes ?](#what-is-docker-volumes-)
- [What is Docker Build ?](#what-is-docker-build-)
- [What are Multi-Stage Builds ?](#what-are-multi-stage-builds-)



### What is Docker ?
- Docker is an open-source platform that enables developers to build, ship, and run applications in isolated environments called containers. It provides a standardized way to package an application and all its dependencies (libraries, frameworks, configuration files) into a single, portable unit.

- **Key Idea**: "Build once, run anywhere." Docker ensures that your application runs consistently across different environments (development, testing, production) because the container includes everything it needs.
- **Containers vs. VMs**: Unlike virtual machines (VMs) which virtualize the entire hardware stack and run a full guest OS, containers share the host OS kernel. This makes them much lighter, faster to start, and more efficient in resource utilization.

- **Images**: A Docker image is a lightweight, standalone, executable package that includes everything needed to run a piece of software, including the code, a runtime, libraries, environment variables, and config files.
- **Containers**: A Docker container is a runnable instance of a Docker image. You can create, start, stop, move, or delete a container.

### What is Docker Compose ?
Docker Compose is a tool for defining and running multi-container Docker applications. Instead of running each container with separate docker run commands, you define all the services, networks, and volumes for your application in a single YAML file (typically docker-compose.yml).


- **Purpose**: Simplifies the management of multi-service applications (e.g., a web app with a database and a caching layer).
- **Workflow**:
    - Define your application's services in docker-compose.yml.
    - Run docker compose up (or docker-compose up in older versions) to start all services defined in the file.
    - Run docker compose down to stop and remove all services.
- **Benefits**: Makes it easy to set up, run, and scale complex applications consistently across different environments.

### What is Docker Volumes ?
Docker Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. When a container is deleted, any data written directly to its writable layer is lost. Volumes provide a way to store data outside the container's lifecycle, on the host machine or a remote storage system.


- **Why use them ?**
    - **Data Persistence**: Data survives container restarts, updates, and deletions.
    - **Data Sharing**: Volumes can be shared between multiple containers.
    - **Performance**: Volumes often offer better I/O performance than writing data directly to the container's writable layer.
    - **Backup/Restore**: Easier to back up and restore data from volumes.
- **Types**:
     - Bind Mounts: Mounts a file or directory from the host machine directly into the container. Good for development (e.g., live code changes).

     - Volumes (Managed by Docker): Docker creates and manages the volume on the host. This is the recommended way for most persistent data storage in production.
     - tmpfs mounts: Temporary mounts in the host's memory, not persistent.

### What is Docker Build ?
Docker Builds refer to the process of creating a Docker image from a Dockerfile. A Dockerfile is a text file that contains a series of instructions that Docker uses to build an image.


- Process:
   - You write a Dockerfile with instructions (e.g., FROM, RUN, COPY, EXPOSE, CMD).
   - You run the docker build command in the directory containing the Dockerfile.
   - Docker executes each instruction in the Dockerfile, creating a new layer for each successful instruction.
   - The final image is a stack of these read-only layers.

- **Example Instructions**:
   - FROM ubuntu:latest: Start from a base Ubuntu image.
   - COPY . /app: Copy local files into the image.
   - RUN apt-get update && apt-get install -y nodejs: Run commands inside the image.
   - EXPOSE 80: Document that the container listens on port 80.
   - CMD ["node", "app.js"]: Default command to run when a container starts from this image.


### What are Multi-Stage Builds ?
Multi-stage builds are an advanced Dockerfile technique that allows you to use multiple FROM statements in a single Dockerfile. Each FROM instruction can use a different base image, and you can selectively copy artifacts from one stage to another.


- Purpose: To create highly optimized and smaller final Docker images, especially for compiled languages (Java, Go, C++, etc.) or frontend applications.
- How it works:
    - Builder Stage: The first stage typically includes all the necessary tools and dependencies to compile, build, or package your application (e.g., a Java JDK, Maven, Node.js for building React apps). This stage can be large.
    - Runtime Stage: The second (and subsequent) stage uses a much smaller, minimal base image (e.g., a JRE for Java, Nginx for a static frontend, a minimal Alpine Linux). Only the essential compiled artifacts or static files from the previous stage are copied into this final stage.
- Benefits:
    - Smaller Image Size: By only copying the necessary runtime artifacts, you avoid including build tools, source code, and intermediate files in the final image, significantly reducing its size.
    - Improved Security: A smaller image means a smaller attack surface (fewer unnecessary libraries, tools).
    - Faster Deployment: Smaller images transfer faster.
    - Cleaner Images: Separates build-time dependencies from runtime dependencies.

**Example (Conceptual)**:

```dockerfile
Dockerfile

# Stage 1: Build the application
FROM maven:3.8.5-openjdk-17 AS builder
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

# Stage 2: Create the final runtime image
FROM openjdk:17-jre-slim-buster
WORKDIR /app
COPY --from=builder /app/target/my-app.jar my-app.jar
EXPOSE 8080
CMD ["java", "-jar", "my-app.jar"]

```
- In this example, the builder stage compiles the Java application. The final stage then only copies the my-app.jar file from the builder stage into a much smaller JRE-only image, resulting in a lean production image.
